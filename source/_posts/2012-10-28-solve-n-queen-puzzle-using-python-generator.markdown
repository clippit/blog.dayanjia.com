---
layout: post
title: "使用Python生成器解决八皇后问题"
date: 2012-10-28 00:37
comments: true
categories:
- 雕虫小技
---

[{% img right http://img.dayanjia.com/dt/FTYD/Eight%20queens%20puzzle.png %}](http://img.dayanjia.com/di/FTYD/Eight%20queens%20puzzle.png)

像我这种对奇特的语言特性很热衷，对算法本身并不热衷也并不擅长的人，似乎很难去写一篇关于算法题的文章。好在我还有一个特点就是不管写了多么烂的代码都会拿出来得瑟一下，不怕被拍砖，于是便来分享一下关于使用Python中的`yield`来解决八皇后问题的心得。

<!--more-->

## Python生成器

[PEP 255](http://www.python.org/dev/peps/pep-0255/)中详细介绍了Python Generator。简单来说它可以将一个函数当作可以迭代的对象来使用，此举真是将高阶函数的特性发挥得淋漓尽致（Java什么的一边玩去吧）。一个很简单的例子：

``` python
def fib():
    a, b = 0, 1
    while 1:
        yield b
        a, b = b, a+b
```

这能够产生一个无穷尽的菲波纳契数列，可以使用`for`死循环般地遍历它：

``` python
for i in fib():
    print i
```

`yield`关键字的要诀就是替换`return`，但是它只是中途返回一个值，而不是将整个函数返回，第二次调用这个函数的时候，会从`yield`之后的地方继续运行。听上去跟闭包（Closures）颇类似呢。

## 八皇后问题

这其实是个讨论得很滥的问题了，所以人们一般称它为『经典问题』。大家知道国际象棋是8×8的棋盘，其中的“皇后”可以横竖斜四通八达地游走和吃子。[八皇后问题](http://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98)就是怎么将八个皇后放在棋盘中，让它们互相不能吃掉。这个问题有92个互不相同的解，如果把旋转和对称的解算做同一种，那便是12个独立解。

## 暴力解决法

很容易看出来，在每一行和每一列上有且只能有一个皇后，因此较为复杂的判断就是对角线了。维基百科的页面上有一个非常暴力但是写起来非常简单的解法：

``` python
from itertools import permutations

n = 8
cols = range(n)
for vec in permutations(cols):
    if (n == len(set(vec[i] + i for i in cols))
          == len(set(vec[i] - i for i in cols))):
        print vec
```

`cols`是一个长度为8的数组，其索引代表第几行，值代表第几列，于是便可以用这个列表来表示8个皇后的坐标了。这个暴力解法将所有可能进行全排列后一个一个地判断是否有对角线共线，所以是非常慢的。

## 稍微不那么暴力的方法

终于到了本文的主题了。稍微不那么暴力的方法就是，一个一个计算列的值，每次的可用值都是依赖于前面已经计算好了的位置的，如果一直运行到最后都有可选择的位置，那么自然就成功了。这样的方法用Generator来实现真是天作之合。

{% gist 3965133 %}

## 从8皇后到N皇后

既然有八皇后，那自然可以将棋盘和皇后数量抽象为N。随着N的增大，程序的速度下降得非常非常非常明显。如果把这个问题的不同解写成一个[数列](http://oeis.org/A000170)的话，那么前几项是这样的：

1.       1
2.       0
3.       0
4.       2
5.       10
6.       4
7.       40
8.       92
9.       352
10.      724
11.      2680
12.      14200
13.      73712
14.      365596
15.      2279184
16.      14772512
17.      95815104
18.      666090624
19.      4968057848
20.      39029188884
21.      314666222712
22.      2691008701644
23.      24233937684440
24.      227514171973736
25.      2207893435808352
26.      22317699616364044

当然了，你用不用想着给它提供一个通项公式的，

Python中存在GIL，在我电脑上最多只能占满25%的CPU。结果在测试n=20时，上面的程序跑了很久很久很久都没有答案出来……
